#!/usr/bin/env python3
"""专用于热点合约指标的前置抢跑触发器。"""

from __future__ import annotations

import argparse
import errno
import hashlib
import json
import os
import sys
import time
from dataclasses import dataclass
from decimal import Decimal
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Sequence, Tuple

from eth_account import Account
from eth_account.signers.local import LocalAccount
from web3 import Web3
from web3.types import TxParams

DEFAULT_BYTECODE = (
    "0x6080604052348015600f57600080fd5b5060c58061001e6000396000f3fe6080604052"
    "6004361060455760003560e01c8063c0e317fb14604a575b600080fd5b606a600480360360"
    "20811015605e57600080fd5b50356088565b60408051918252519081900360200190f35b60"
    "006000546001600160a01b03168156fea2646970667358221220645c41fbbf21ceae5fa18c"
    "f6d2d4c2de142c8f869f4f6fee577e0722b8aaabf364736f6c63430008160033"
)

PIPE_TX_SCHEMA = "fr-hotspot-tx-v1"
PIPE_META_SCHEMA = "fr-hotspot-metadata-v1"
GROUND_TRUTH_SCHEMA = "fr-hotspot-event-v1"


# ---------------------------------------------------------------------------
# 参数解析辅助
# ---------------------------------------------------------------------------


def positive_int(value: str) -> int:
    ivalue = int(value, 0)
    if ivalue <= 0:
        raise argparse.ArgumentTypeError("value must be positive")
    return ivalue


def non_negative_int(value: str) -> int:
    ivalue = int(value, 0)
    if ivalue < 0:
        raise argparse.ArgumentTypeError("value must be non-negative")
    return ivalue


def parse_wei(value: str) -> int:
    text = value.strip().lower()
    if text.endswith("eth"):
        amount = Decimal(text[:-3]) * Decimal(10**18)
    elif text.endswith("gwei"):
        amount = Decimal(text[:-4]) * Decimal(10**9)
    elif text.endswith("wei"):
        amount = Decimal(text[:-3])
    else:
        amount = Decimal(text)
    result = int(amount)
    if result < 0:
        raise argparse.ArgumentTypeError("amount must be non-negative")
    return result


def parse_marker(value: str) -> bytes:
    if not value.startswith("0x"):
        raise argparse.ArgumentTypeError("marker must start with 0x")
    body = value[2:]
    if len(body) % 2:
        raise argparse.ArgumentTypeError("marker hex length must be even")
    try:
        return bytes.fromhex(body)
    except ValueError as exc:  # noqa: B904
        raise argparse.ArgumentTypeError(f"invalid marker: {exc}") from exc


# ---------------------------------------------------------------------------
# 账户模型与输出通道
# ---------------------------------------------------------------------------


@dataclass
class ManagedAccount:
    label: str
    signer: LocalAccount
    nonce: Optional[int] = None

    @property
    def address(self) -> str:
        return Web3.to_checksum_address(self.signer.address)

    def next_nonce(self, provider: Web3) -> int:
        if self.nonce is None:
            self.nonce = provider.eth.get_transaction_count(self.address, "pending")
        value = self.nonce
        self.nonce += 1
        return value


class OutputChannels:
    def __init__(self, table_path: Optional[Path], pipe_path: Optional[Path]):
        self._table_fp = None
        self._pipe_fp = None
        if table_path:
            table_path.parent.mkdir(parents=True, exist_ok=True)
            self._table_fp = table_path.open("a", encoding="utf-8")
        if pipe_path:
            self._pipe_fp = self._open_fifo(pipe_path)

    def close(self) -> None:
        if self._table_fp:
            self._table_fp.close()
            self._table_fp = None
        if self._pipe_fp:
            self._pipe_fp.close()
            self._pipe_fp = None

    def write_ground_truth(self, record: Dict[str, object]) -> None:
        line = json.dumps(record, ensure_ascii=True)
        if self._table_fp:
            self._table_fp.write(line + "\n")
            self._table_fp.flush()
        else:
            print(line)

    def write_pipe(self, record: Dict[str, object]) -> None:
        if not self._pipe_fp:
            return
        line = json.dumps(record, ensure_ascii=True)
        try:
            self._pipe_fp.write(line + "\n")
            self._pipe_fp.flush()
        except BrokenPipeError:
            print("[PIPE] consumer disconnected; disable pipe output", file=sys.stderr)
            self._pipe_fp.close()
            self._pipe_fp = None

    @staticmethod
    def _open_fifo(pipe_path: Path):
        if os.name == "nt":  # pragma: no cover
            raise SystemExit("Named pipe streaming requires POSIX platforms")
        if pipe_path.exists() and not pipe_path.is_fifo():
            raise SystemExit(f"target {pipe_path} exists but is not FIFO")
        if not pipe_path.exists():
            os.mkfifo(pipe_path, 0o660)
        deadline = time.time() + 10
        while True:
            try:
                fd = os.open(str(pipe_path), os.O_WRONLY | os.O_NONBLOCK)
                break
            except OSError as exc:  # noqa: PERF203
                if exc.errno != errno.ENXIO:
                    raise
                if time.time() >= deadline:
                    raise SystemExit("Timed out waiting for pipe consumer") from exc
                time.sleep(0.5)
        return os.fdopen(fd, "w", buffering=1, encoding="utf-8")


# ---------------------------------------------------------------------------
# RPC / 账号准备
# ---------------------------------------------------------------------------


def connect_rpcs(urls: Sequence[str]) -> Tuple[List[Web3], int]:
    if not urls:
        raise SystemExit("at least one --rpc endpoint required")
    providers: List[Web3] = []
    for url in urls:
        w3 = Web3(Web3.HTTPProvider(url, request_kwargs={"timeout": 30}))
        if not w3.is_connected():
            raise SystemExit(f"failed to connect to RPC: {url}")
        providers.append(w3)
    chain_id = providers[0].eth.chain_id
    for w3 in providers[1:]:
        if w3.eth.chain_id != chain_id:
            raise SystemExit("all RPC endpoints must belong to the same chain")
    return providers, chain_id


def load_master(args: argparse.Namespace) -> ManagedAccount:
    raw = os.getenv("ATTACKER_KEYSTORE")
    if not raw:
        raise SystemExit("ATTACKER_KEYSTORE environment variable not set")
    try:
        payload = json.loads(raw)
    except json.JSONDecodeError as exc:  # noqa: B904
        raise SystemExit(f"failed to parse ATTACKER_KEYSTORE JSON: {exc}") from exc

    passphrase = args.passphrase
    if passphrase is None:
        from getpass import getpass

        passphrase = getpass("Keystore passphrase: ")
    try:
        key = Account.decrypt(payload, passphrase)
    except ValueError as exc:  # noqa: B904
        raise SystemExit(f"keystore decryption failed: {exc}") from exc
    acct = Account.from_key(key)
    return ManagedAccount(label="master", signer=acct)


def generate_children(quantity: int) -> List[ManagedAccount]:
    result: List[ManagedAccount] = []
    for idx in range(quantity):
        child = Account.create()
        result.append(ManagedAccount(label=f"child-{idx + 1}", signer=child))
    return result


def ensure_balance(provider: Web3, address: str, minimum: int) -> None:
    balance = provider.eth.get_balance(address)
    if balance < minimum:
        raise SystemExit(f"master balance {balance} wei insufficient (< {minimum} wei)")


def send_signed(provider: Web3, sender: ManagedAccount, tx: TxParams, dry_run: bool) -> str:
    if dry_run:
        digest = hashlib.sha1(repr(tx).encode("ascii")).hexdigest()
        return "0xDRY" + digest[:32]
    signed = sender.signer.sign_transaction(tx)
    raw_tx = getattr(signed, "rawTransaction", None) or getattr(signed, "raw_transaction", None)
    if raw_tx is None:
        raise RuntimeError("signed transaction missing raw bytes")
    tx_hash = provider.eth.send_raw_transaction(raw_tx)
    return Web3.to_hex(tx_hash)


def wait_for_receipt(provider: Web3, tx_hash: str, timeout: int) -> Dict[str, object]:
    return provider.eth.wait_for_transaction_receipt(tx_hash, timeout=timeout)


# ---------------------------------------------------------------------------
# 部署与目标地址规划
# ---------------------------------------------------------------------------


def deploy_contracts(
    providers: Sequence[Web3],
    master: ManagedAccount,
    chain_id: int,
    count: int,
    gas_limit: int,
    gas_price: int,
    dry_run: bool,
    interval: float,
    receipt_timeout: int,
) -> List[str]:
    if count <= 0:
        return []
    deployed: List[str] = []
    provider = providers[0]
    for idx in range(count):
        nonce = master.next_nonce(provider)
        tx: TxParams = {
            "chainId": chain_id,
            "nonce": nonce,
            "to": None,
            "value": 0,
            "gas": gas_limit,
            "gasPrice": gas_price,
            "data": DEFAULT_BYTECODE,
        }
        tx_hash = send_signed(provider, master, tx, dry_run)
        if dry_run:
            contract_address = f"0xDRYCONTRACT{idx:04d}"[:42]
        else:
            receipt = wait_for_receipt(provider, tx_hash, receipt_timeout)
            contract_address = Web3.to_checksum_address(receipt["contractAddress"])
        deployed.append(contract_address)
        print(f"[DEPLOY] idx={idx + 1}/{count} addr={contract_address} hash={tx_hash}")
        if idx + 1 < count and interval > 0:
            time.sleep(interval)
    return deployed


def normalize_addresses(addresses: Iterable[str]) -> List[str]:
    result: List[str] = []
    for addr in addresses:
        try:
            result.append(Web3.to_checksum_address(addr))
        except Exception:  # noqa: BLE001
            print(f"[WARN] skip invalid address: {addr}")
    return result


def build_target_plan(
    count: int,
    hot_targets: List[str],
    all_targets: List[str],
    hot_share: float,
) -> List[str]:
    total = max(count, 0)
    if not all_targets:
        raise SystemExit("no target contracts available")
    hot_targets = hot_targets or all_targets
    hot_lower = {addr.lower() for addr in hot_targets}
    non_hot = [addr for addr in all_targets if addr.lower() not in hot_lower]
    hot_quota = min(total, max(0, int(round(total * hot_share)))) if hot_targets else 0
    cold_quota = total - hot_quota
    plan: List[Tuple[str, str]] = []
    hot_cycle = iter_cycle(hot_targets)
    cold_cycle = iter_cycle(non_hot if non_hot else hot_targets)
    for _ in range(hot_quota):
        plan.append(("hot", next(hot_cycle)))
    for _ in range(cold_quota):
        plan.append(("cold", next(cold_cycle)))
    result: List[str] = []
    hot_index = 0
    cold_index = hot_quota
    while len(result) < total:
        if hot_index < hot_quota:
            result.append(plan[hot_index][1])
            hot_index += 1
        if len(result) >= total:
            break
        if cold_index < len(plan):
            result.append(plan[cold_index][1])
            cold_index += 1
        if len(result) >= total:
            break
    while len(result) < total and plan:
        result.append(plan[hot_index % max(1, hot_quota or len(plan))][1])
        hot_index += 1
    return result


def iter_cycle(addresses: Sequence[str]):
    if not addresses:
        raise SystemExit("cannot build cycle from empty address list")
    while True:
        for addr in addresses:
            yield addr


# ---------------------------------------------------------------------------
# 核心发送逻辑
# ---------------------------------------------------------------------------


def run_pairs(
    providers: Sequence[Web3],
    accounts: Sequence[ManagedAccount],
    targets: List[str],
    hot_targets: List[str],
    hot_lower: set[str],
    args: argparse.Namespace,
    channels: OutputChannels,
    chain_id: int,
) -> None:
    marker_bytes = parse_marker(args.marker)
    provider = providers[0]
    schedule = build_target_plan(args.count, hot_targets, targets, args.hot_share)

    def choose_accounts(index: int) -> Tuple[ManagedAccount, ManagedAccount]:
        victim = accounts[index % len(accounts)]
        runner = accounts[(index + 1) % len(accounts)]
        if victim.address == runner.address:
            runner = accounts[(index + 2) % len(accounts)]
        return victim, runner

    for pair_id, target in enumerate(schedule, start=1):
        victim_acct, runner_acct = choose_accounts(pair_id - 1)
        victim_nonce = victim_acct.next_nonce(provider)
        runner_nonce = runner_acct.next_nonce(provider)
        victim_payload = marker_bytes + b"\x01" + pair_id.to_bytes(4, "big")
        runner_payload = marker_bytes + b"\x02" + pair_id.to_bytes(4, "big")

        victim_tx: TxParams = {
            "chainId": chain_id,
            "nonce": victim_nonce,
            "to": target,
            "value": args.transfer_amount,
            "gas": args.victim_gas,
            "gasPrice": args.victim_gas_price,
            "data": victim_payload,
        }
        runner_tx: TxParams = {
            "chainId": chain_id,
            "nonce": runner_nonce,
            "to": target,
            "value": args.transfer_amount,
            "gas": args.runner_gas,
            "gasPrice": args.victim_gas_price + args.runner_premium,
            "data": runner_payload,
        }

        victim_hash = send_signed(provider, victim_acct, victim_tx, args.dry_run)
        runner_hash = send_signed(provider, runner_acct, runner_tx, args.dry_run)
        is_hot_truth = target.lower() in hot_lower
        event_id = hashlib.sha1((victim_hash + runner_hash).encode("ascii")).hexdigest()[:16]
        timestamp = time.time()

        channels.write_ground_truth(
            {
                "schema": GROUND_TRUTH_SCHEMA,
                "event_id": event_id,
                "pair_id": pair_id,
                "victim_hash": victim_hash,
                "runner_hash": runner_hash,
                "victim_address": victim_acct.address,
                "runner_address": runner_acct.address,
                "target_address": target,
                "victim_nonce": victim_nonce,
                "runner_nonce": runner_nonce,
                "victim_gas_price": args.victim_gas_price,
                "runner_gas_price": args.victim_gas_price + args.runner_premium,
                "is_hot_truth": is_hot_truth,
                "marker": args.marker,
                "timestamp": timestamp,
            }
        )

        channels.write_pipe(
            {
                "schema": PIPE_TX_SCHEMA,
                "pair_id": pair_id,
                "role": "victim",
                "tx_hash": victim_hash,
                "from": victim_acct.address,
                "to": target,
                "nonce": victim_nonce,
                "gas": args.victim_gas,
                "gas_price": args.victim_gas_price,
                "is_hot_truth": is_hot_truth,
                "timestamp": timestamp,
            }
        )
        channels.write_pipe(
            {
                "schema": PIPE_TX_SCHEMA,
                "pair_id": pair_id,
                "role": "runner",
                "tx_hash": runner_hash,
                "from": runner_acct.address,
                "to": target,
                "nonce": runner_nonce,
                "gas": args.runner_gas,
                "gas_price": args.victim_gas_price + args.runner_premium,
                "is_hot_truth": is_hot_truth,
                "timestamp": timestamp,
            }
        )

        print(
            "[PAIR] id={}/{} target={} hot={} victim={} runner={}".format(
                pair_id,
                args.count,
                target,
                is_hot_truth,
                victim_hash,
                runner_hash,
            )
        )
        if pair_id < args.count and args.interval > 0:
            time.sleep(args.interval)


# ---------------------------------------------------------------------------
# 入口
# ---------------------------------------------------------------------------


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Hot-contract metric trigger")
    parser.add_argument("--rpc", action="append", required=True, help="HTTP RPC endpoint; repeatable")
    parser.add_argument("--count", type=positive_int, default=60, help="Number of victim/runner pairs")
    parser.add_argument("--marker", default="0xfeedface", help="Marker prefix for calldata")
    parser.add_argument("--runner-premium", type=parse_wei, default="30gwei", help="Runner gas price premium")
    parser.add_argument("--victim-gas-price", type=parse_wei, default="0", help="Baseline victim gas price")
    parser.add_argument("--victim-gas", type=positive_int, default=120000, help="Gas limit for victim tx")
    parser.add_argument("--runner-gas", type=positive_int, default=120000, help="Gas limit for runner tx")
    parser.add_argument("--transfer-amount", type=parse_wei, default="0", help="ETH value attached to tx")
    parser.add_argument("--accounts", type=positive_int, default=3, help="Total sending accounts including master")
    parser.add_argument("--fund-amount", type=parse_wei, default="0.05eth", help="Funding amount per child account")
    parser.add_argument("--fund-gas", type=positive_int, default=21000, help="Gas limit for funding transfers")
    parser.add_argument("--deploy-contracts", type=non_negative_int, default=2, help="Number of helper contracts to deploy")
    parser.add_argument("--deploy-gas", type=positive_int, default=550000, help="Gas limit for contract deployment")
    parser.add_argument("--target", action="append", help="Additional existing contract address; repeatable")
    parser.add_argument("--hot-contract", action="append", help="Designated hot contract address; repeatable")
    parser.add_argument("--hot-share", type=float, default=0.5, help="Fraction of pairs targeting hot contracts (0-1)")
    parser.add_argument("--interval", type=float, default=0.05, help="Delay between consecutive pairs")
    parser.add_argument("--output", type=Path, help="Ground-truth JSONL output path")
    parser.add_argument("--pipe", type=Path, help="Named pipe path for realtime streaming")
    parser.add_argument("--dry-run", action="store_true", help="Do not broadcast transactions")
    parser.add_argument("--chain-id", type=positive_int, help="Override detected chain id")
    parser.add_argument("--passphrase", help="Passphrase for ATTACKER_KEYSTORE")
    parser.add_argument("--receipt-timeout", type=positive_int, default=120, help="Seconds to wait for receipts")
    parser.add_argument("--balance-timeout", type=positive_int, default=120, help="Seconds to wait for funding balances")
    return parser.parse_args()


def fund_children(
    provider: Web3,
    master: ManagedAccount,
    children: Sequence[ManagedAccount],
    chain_id: int,
    args: argparse.Namespace,
) -> None:
    if not children or args.fund_amount == 0:
        return
    for child in children:
        nonce = master.next_nonce(provider)
        tx: TxParams = {
            "chainId": chain_id,
            "nonce": nonce,
            "to": child.address,
            "value": args.fund_amount,
            "gas": args.fund_gas,
            "gasPrice": max(args.victim_gas_price, 1),
        }
        tx_hash = send_signed(provider, master, tx, args.dry_run)
        print(f"[FUND] child={child.address} value={args.fund_amount} hash={tx_hash}")
        if not args.dry_run:
            provider.eth.wait_for_transaction_receipt(tx_hash, timeout=args.receipt_timeout)
            deadline = time.time() + args.balance_timeout
            while time.time() < deadline:
                if provider.eth.get_balance(child.address) >= args.fund_amount:
                    break
                time.sleep(2)
            else:
                raise SystemExit(f"timed out waiting for {child.address} balance")
        if args.interval > 0:
            time.sleep(args.interval)


def main() -> None:
    args = parse_args()
    args.hot_share = max(0.0, min(args.hot_share, 1.0))
    providers, detected_chain_id = connect_rpcs(args.rpc)
    chain_id = args.chain_id or detected_chain_id
    base_provider = providers[0]

    master = load_master(args)
    print(f"[MASTER] loaded {master.address}")

    if args.victim_gas_price == 0:
        args.victim_gas_price = base_provider.eth.gas_price
        print(f"[GAS] victim gas price set to node suggestion {args.victim_gas_price} wei")

    required_balance = args.fund_amount * max(args.accounts - 1, 0) + args.deploy_contracts * args.victim_gas_price * args.deploy_gas
    ensure_balance(base_provider, master.address, required_balance)

    total_accounts = max(args.accounts, 2)
    children = generate_children(total_accounts - 1)
    accounts: List[ManagedAccount] = [master] + list(children)

    ground_truth_path = Path(args.output) if args.output else None
    pipe_path = Path(args.pipe) if args.pipe else None
    channels = OutputChannels(ground_truth_path, pipe_path)

    try:
        fund_children(base_provider, master, children, chain_id, args)
        deployed = deploy_contracts(
            providers,
            master,
            chain_id,
            args.deploy_contracts,
            args.deploy_gas,
            max(args.victim_gas_price, 1),
            args.dry_run,
            args.interval,
            args.receipt_timeout,
        )
        targets = normalize_addresses(args.target or [])
        targets.extend([addr for addr in deployed if addr not in targets])
        if args.hot_contract:
            hot_manual = normalize_addresses(args.hot_contract)
            for addr in hot_manual:
                if addr not in targets:
                    targets.append(addr)
        if not targets:
            targets = deployed
        if not targets:
            raise SystemExit("no target contracts available; supply --target or enable deployments")

        hot_set = {addr.lower() for addr in normalize_addresses(args.hot_contract or [])}
        if not hot_set:
            hot_set = {targets[0].lower()}
        hot_targets = [addr for addr in targets if addr.lower() in hot_set]
        if not hot_targets:
            target = Web3.to_checksum_address(next(iter(hot_set)))
            targets.append(target)
            hot_targets = [target]

        channels.write_pipe(
            {
                "schema": PIPE_META_SCHEMA,
                "hot_contracts": sorted(hot_set),
                "targets": targets,
                "timestamp": time.time(),
            }
        )

        run_pairs(
            providers,
            accounts,
            targets,
            hot_targets,
            {addr.lower() for addr in hot_targets},
            args,
            channels,
            chain_id,
        )
        print(f"[DONE] emitted {args.count} pair(s) across {len(targets)} contract(s)")
    finally:
        channels.close()


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("Interrupted by user", file=sys.stderr)
        sys.exit(130)
